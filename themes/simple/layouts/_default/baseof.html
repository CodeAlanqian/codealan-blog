{{ $styles := resources.Get "css/main.css" | toCSS | minify | fingerprint }}
<!DOCTYPE html>
<html lang="{{ site.Language.Lang }}">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>{{ if .IsHome }}{{ site.Title }}{{ else }}{{ .Title }} Â· {{ site.Title }}{{ end }}</title>
  {{ with site.Params.description }}<meta name="description" content="{{ . }}">{{ end }}
  <link rel="icon" href="{{ "/avatar.png" | relURL }}" type="image/png">
  <link rel="stylesheet" href="{{ $styles.RelPermalink }}" integrity="{{ $styles.Data.Integrity }}">
  {{ if .Params.math }}
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.css">
  {{ end }}
</head>
<body class="no-js">
  <header class="site-header">
    <div class="brand">
      <a href="{{ "/" | relURL }}">{{ site.Title }}</a>
      {{ with site.Params.description }}<p class="tagline">{{ . }}</p>{{ end }}
    </div>
    <div class="header-actions">
      {{ if not .IsHome }}
        <button class="back-btn" id="backBtn" aria-label="è¿”å›ä¸Šä¸€çº§" type="button">
          <span aria-hidden="true">â†</span>
          <span class="back-label">è¿”å›</span>
        </button>
      {{ end }}
      <button class="theme-toggle" id="themeToggle" aria-label="åˆ‡æ¢ä¸»é¢˜" type="button">â˜€ï¸</button>
      {{ $searchMenu := where site.Menus.main "Name" "==" "æœç´¢" }}
      {{ with index $searchMenu 0 }}
        <a href="{{ .URL }}" class="search-icon"
           aria-label="æœç´¢">
          <span aria-hidden="true">ğŸ”</span>
          <span class="sr-only">æœç´¢</span>
        </a>
      {{ end }}
      <nav class="site-nav">
        {{ range site.Menus.main }}
          {{ if ne .Name "æœç´¢" }}
            <a href="{{ .URL }}" {{ if $.IsMenuCurrent "main" . }}aria-current="page"{{ end }}>{{ .Name }}</a>
          {{ end }}
        {{ end }}
      </nav>
    </div>
  </header>
  <div class="reading-progress" aria-hidden="true">
    <div class="reading-progress-bar" id="readingProgressBar"></div>
  </div>
  <main class="site-main">
    {{ block "main" . }}{{ end }}
  </main>
  {{ partial "ai-chat.html" . }}
  <button class="back-top" id="backTopBtn" type="button" aria-label="å›åˆ°é¡¶éƒ¨">â†‘</button>
  <footer class="site-footer">
    <p>Â© {{ now.Format "2006" }} CodeAlan Â· Powered by Hugo</p>
    <p><a href="https://beian.miit.gov.cn" target="_blank" rel="noreferrer">ç²¤ICPå¤‡2023012271å·-1</a></p>
  </footer>
  {{ if .Params.math }}
    <script src="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/contrib/auto-render.min.js"></script>
  {{ end }}
  <script>
    (function() {
      const root = document.documentElement;
      const body = document.body;
      const toggle = document.getElementById('themeToggle');
      const storageKey = 'theme';
      const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
      const saved = localStorage.getItem(storageKey);
      const initial = saved || (prefersDark ? 'dark' : 'light');
      const apply = (mode) => {
        if (mode === 'dark') {
          root.classList.add('dark');
          toggle.textContent = 'ğŸŒ™';
        } else {
          root.classList.remove('dark');
          toggle.textContent = 'â˜€ï¸';
        }
        localStorage.setItem(storageKey, mode);
      };
      body.classList.remove('no-js');
      apply(initial);
      toggle.addEventListener('click', () => {
        const next = root.classList.contains('dark') ? 'light' : 'dark';
        apply(next);
      });
    })();
    (function() {
      const isTypingTarget = (el) => {
        if (!el) return false;
        const tag = el.tagName;
        const editable = el.isContentEditable;
        return editable ||
          tag === 'INPUT' ||
          tag === 'TEXTAREA' ||
          tag === 'SELECT';
      };
      document.addEventListener('keydown', (e) => {
        if (e.defaultPrevented) return;
        if (isTypingTarget(e.target)) return;
        if (e.key === '/' && !e.metaKey && !e.ctrlKey && !e.altKey && !e.altKey) {
          const search = document.getElementById('searchInput');
          if (search) {
            e.preventDefault();
            search.focus();
            search.select();
          } else {
            window.location.href = '{{ "/search/" | relURL }}';
          }
        }
        if (e.key === 't' && !e.metaKey && !e.ctrlKey && !e.altKey) {
          e.preventDefault();
          window.scrollTo({ top: 0, behavior: 'smooth' });
        }
        if ((e.key === 'j' || e.key === 'k') && !e.metaKey && !e.ctrlKey && !e.altKey) {
          const prev = document.querySelector('.post-nav-link.prev');
          const next = document.querySelector('.post-nav-link.next');
          if (e.key === 'j' && next) {
            window.location.href = next.getAttribute('href');
          } else if (e.key === 'k' && prev) {
            window.location.href = prev.getAttribute('href');
          }
        }
      });
    })();
    (function() {
      const backBtn = document.getElementById('backBtn');
      if (!backBtn) return;
      backBtn.addEventListener('click', () => {
        if (window.history.length > 1) {
          window.history.back();
        } else {
          window.location.href = '{{ "/" | relURL }}';
        }
      });
    })();
    (function() {
      const buttons = document.querySelectorAll('.copy-btn');
      buttons.forEach((btn) => {
        btn.addEventListener('click', () => {
          const pre = btn.nextElementSibling;
          if (!pre) return;
          const codeEl = pre.querySelector('code') || pre;
          const text = codeEl.textContent;
          const write = navigator.clipboard && navigator.clipboard.writeText
            ? navigator.clipboard.writeText(text)
            : Promise.reject();
          write.then(() => {
            btn.textContent = 'å·²å¤åˆ¶';
            setTimeout(() => (btn.textContent = 'å¤åˆ¶'), 1200);
          }).catch(() => {
            try {
              const textarea = document.createElement('textarea');
              textarea.value = text;
              document.body.appendChild(textarea);
              textarea.select();
              document.execCommand('copy');
              document.body.removeChild(textarea);
              btn.textContent = 'å·²å¤åˆ¶';
              setTimeout(() => (btn.textContent = 'å¤åˆ¶'), 1200);
            } catch (e) {}
          });
        });
      });
    })();
    (function() {
      const article = document.querySelector('.post .content');
      if (!article) return;
      const headings = article.querySelectorAll('h2[id], h3[id], h4[id]');
      headings.forEach((h) => {
        const id = h.id;
        if (!id) return;
        const anchor = document.createElement('button');
        anchor.type = 'button';
        anchor.className = 'heading-anchor';
        anchor.textContent = '#';
        anchor.addEventListener('click', (e) => {
          e.stopPropagation();
          const url = window.location.origin + window.location.pathname + '#' + id;
          const write = navigator.clipboard && navigator.clipboard.writeText
            ? navigator.clipboard.writeText(url)
            : Promise.reject();
          write.then(() => {
            anchor.textContent = 'å·²å¤åˆ¶';
            setTimeout(() => (anchor.textContent = '#'), 1200);
          }).catch(() => {
            try {
              const textarea = document.createElement('textarea');
              textarea.value = url;
              document.body.appendChild(textarea);
              textarea.select();
              document.execCommand('copy');
              document.body.removeChild(textarea);
              anchor.textContent = 'å·²å¤åˆ¶';
              setTimeout(() => (anchor.textContent = '#'), 1200);
            } catch (e) {}
          });
        });
        h.appendChild(anchor);
      });
    })();
    (function() {
      const container = document.getElementById('aiMindmap');
      const article = document.querySelector('.post .content');
      if (!container || !article) return;
      const headings = Array.from(article.querySelectorAll('h2[id], h3[id]'));
      if (!headings.length) return;
      const nodes = [];
      const edges = [];
      const rootId = '__root__';
      nodes.push({ id: rootId, label: 'æœ¬æ–‡ç»“æ„', level: 0 });
      let lastH2 = null;
      headings.forEach((h) => {
        const level = h.tagName === 'H2' ? 1 : 2;
        const id = h.id || '';
        const label = (h.textContent || '').trim();
        if (!label) return;
        nodes.push({ id, label, level, targetId: id });
        if (level === 1) {
          edges.push({ source: rootId, target: id });
          lastH2 = id;
        } else if (lastH2) {
          edges.push({ source: lastH2, target: id });
        } else {
          edges.push({ source: rootId, target: id });
        }
      });
      if (nodes.length <= 1) return;
      const width = container.clientWidth || 420;
      const height = 220;
      const svgNS = 'http://www.w3.org/2000/svg';
      const svg = document.createElementNS(svgNS, 'svg');
      svg.setAttribute('viewBox', `0 0 ${width} ${height}`);
      svg.setAttribute('class', 'ai-mindmap-svg');

      const levelGroups = { 0: [], 1: [], 2: [] };
      nodes.forEach((n) => {
        const l = n.level || 0;
        if (!levelGroups[l]) levelGroups[l] = [];
        levelGroups[l].push(n);
      });
      const colX = {
        0: width * 0.12,
        1: width * 0.45,
        2: width * 0.78
      };
      const placeLevel = (level) => {
        const list = levelGroups[level] || [];
        const count = list.length || 1;
        const gap = height / (count + 1);
        list.forEach((n, i) => {
          n.x = colX[level];
          n.y = gap * (i + 1);
        });
      };
      placeLevel(0);
      placeLevel(1);
      placeLevel(2);

      const idMap = new Map(nodes.map(n => [n.id, n]));

      edges.forEach((e) => {
        const s = idMap.get(e.source);
        const t = idMap.get(e.target);
        if (!s || !t) return;
        const line = document.createElementNS(svgNS, 'line');
        line.setAttribute('class', 'ai-mindmap-edge');
        line.setAttribute('x1', s.x);
        line.setAttribute('y1', s.y);
        line.setAttribute('x2', t.x);
        line.setAttribute('y2', t.y);
        svg.appendChild(line);
      });

      nodes.forEach((n) => {
        const g = document.createElementNS(svgNS, 'g');
        g.setAttribute('class', 'ai-mindmap-node');
        const circle = document.createElementNS(svgNS, 'circle');
        circle.setAttribute('class', 'ai-mindmap-circle');
        circle.setAttribute('cx', n.x);
        circle.setAttribute('cy', n.y);
        circle.setAttribute('r', n.level === 0 ? 11 : 8);
        const label = document.createElementNS(svgNS, 'text');
        label.setAttribute('class', 'ai-mindmap-label');
        label.setAttribute('x', n.x + (n.level === 0 ? 0 : 10));
        label.setAttribute('y', n.y + 3);
        label.setAttribute('text-anchor', n.level === 0 ? 'middle' : 'start');
        label.textContent = n.label;
        g.appendChild(circle);
        g.appendChild(label);
        if (n.targetId) {
          g.addEventListener('click', () => {
            const target = document.getElementById(n.targetId);
            if (target) {
              target.scrollIntoView({ behavior: 'smooth', block: 'start' });
            }
          });
        }
        svg.appendChild(g);
      });

      container.appendChild(svg);
    })();
    (function() {
      const btn = document.getElementById('postShareBtn');
      if (!btn || typeof window === 'undefined') return;
      btn.addEventListener('click', () => {
        const url = window.location.href;
        const write = navigator.clipboard && navigator.clipboard.writeText
          ? navigator.clipboard.writeText(url)
          : Promise.reject();
        write.then(() => {
          btn.textContent = 'å·²å¤åˆ¶é“¾æ¥';
          setTimeout(() => (btn.textContent = 'å¤åˆ¶æœ¬é¡µé“¾æ¥'), 1200);
        }).catch(() => {
          try {
            const textarea = document.createElement('textarea');
            textarea.value = url;
            document.body.appendChild(textarea);
            textarea.select();
            document.execCommand('copy');
            document.body.removeChild(textarea);
            btn.textContent = 'å·²å¤åˆ¶é“¾æ¥';
            setTimeout(() => (btn.textContent = 'å¤åˆ¶æœ¬é¡µé“¾æ¥'), 1200);
          } catch (e) {}
        });
      });
    })();
    (function() {
      const btn = document.getElementById('postPptBtn');
      if (!btn) return;
      const content = document.querySelector('.post .content');
      if (!content) return;
      btn.addEventListener('click', () => {
        const blocks = Array.from(content.children);
        const slides = [];
        let current = null;
        blocks.forEach((node) => {
          if (node.matches && node.matches('h2, h3')) {
            current = { title: node.textContent || '', nodes: [] };
            slides.push(current);
          } else if (current) {
            current.nodes.push(node.cloneNode(true));
          }
        });
        if (!slides.length) {
          current = { title: document.title, nodes: [content.cloneNode(true)] };
          slides.push(current);
        }
        const overlay = document.createElement('div');
        overlay.className = 'ppt-overlay';
        overlay.dataset.pptActive = 'true';
        const header = document.createElement('div');
        header.className = 'ppt-header';
        const titleEl = document.createElement('div');
        titleEl.textContent = document.title;
        const closeBtn = document.createElement('button');
        closeBtn.type = 'button';
        closeBtn.className = 'ppt-btn';
        closeBtn.textContent = 'é€€å‡º';
        header.appendChild(titleEl);
        header.appendChild(closeBtn);
        const body = document.createElement('div');
        body.className = 'ppt-body';
        const footer = document.createElement('div');
        footer.className = 'ppt-footer';
        const hint = document.createElement('div');
        hint.textContent = 'â† / â†’ åˆ‡æ¢ä¸Šä¸€é¡µ/ä¸‹ä¸€é¡µ Â· Esc é€€å‡º';
        const controls = document.createElement('div');
        controls.className = 'ppt-controls';
        const prevBtn = document.createElement('button');
        prevBtn.type = 'button';
        prevBtn.className = 'ppt-btn';
        prevBtn.textContent = 'ä¸Šä¸€é¡µ';
        const nextBtn = document.createElement('button');
        nextBtn.type = 'button';
        nextBtn.className = 'ppt-btn';
        nextBtn.textContent = 'ä¸‹ä¸€é¡µ';
        controls.appendChild(prevBtn);
        controls.appendChild(nextBtn);
        footer.appendChild(hint);
        footer.appendChild(controls);
        overlay.appendChild(header);
        overlay.appendChild(body);
        overlay.appendChild(footer);
        const slideEls = slides.map((slide, idx) => {
          const el = document.createElement('div');
          el.className = 'ppt-slide';
          const h = document.createElement('h2');
          h.textContent = slide.title || ('Slide ' + (idx + 1));
          el.appendChild(h);
          slide.nodes.forEach((node) => el.appendChild(node));
          body.appendChild(el);
          return el;
        });
        let index = 0;
        const update = () => {
          slideEls.forEach((el, i) => {
            el.classList.toggle('is-active', i === index);
          });
        };
        const cleanup = () => {
          if (overlay.parentNode) {
            document.body.removeChild(overlay);
          }
          document.removeEventListener('keydown', onKey);
        };
        const onKey = (e) => {
          if (e.key === 'Escape') {
            e.preventDefault();
            cleanup();
          } else if (e.key === 'ArrowRight' || e.key === 'PageDown' || e.key === ' ') {
            e.preventDefault();
            if (index < slideEls.length - 1) {
              index += 1;
              update();
            }
          } else if (e.key === 'ArrowLeft' || e.key === 'PageUp') {
            e.preventDefault();
            if (index > 0) {
              index -= 1;
              update();
            }
          }
        };
        prevBtn.addEventListener('click', () => {
          if (index > 0) {
            index -= 1;
            update();
          }
        });
        nextBtn.addEventListener('click', () => {
          if (index < slideEls.length - 1) {
            index += 1;
            update();
          }
        });
        closeBtn.addEventListener('click', cleanup);
        document.addEventListener('keydown', onKey);
        document.body.appendChild(overlay);
        index = 0;
        update();
      });
    })();
    (function() {
      const article = document.querySelector('.post .content');
      if (!article) return;
      const imgs = article.querySelectorAll('img');
      if (!imgs.length) return;
      imgs.forEach((img) => {
        img.style.cursor = 'zoom-in';
        img.addEventListener('click', () => {
          if (img.dataset.noLightbox === 'true') return;
          const overlay = document.createElement('div');
          overlay.className = 'lightbox-overlay';
          const big = document.createElement('img');
          big.src = img.src;
          big.alt = img.alt || '';
          overlay.appendChild(big);
          overlay.addEventListener('click', (e) => {
            if (e.target === overlay) {
              document.body.removeChild(overlay);
            }
          });
          document.addEventListener('keydown', function onKey(ev) {
            if (ev.key === 'Escape') {
              if (overlay.parentNode) {
                document.body.removeChild(overlay);
              }
              document.removeEventListener('keydown', onKey);
            }
          });
          document.body.appendChild(overlay);
        });
      });
    })();
    (function() {
      const el = document.querySelector('.view-count');
      if (!el || typeof window === 'undefined') return;
      const key = el.getAttribute('data-key') || window.location.pathname;

      const updateLocalFallback = () => {
        if (!window.localStorage) return;
        const storageKey = 'views:' + key;
        let count = 0;
        try {
          const raw = localStorage.getItem(storageKey);
          if (raw) count = parseInt(raw, 10) || 0;
        } catch (e) {}
        count += 1;
        el.textContent = count;
        try {
          localStorage.setItem(storageKey, String(count));
        } catch (e) {}
      };

      // ä¼˜å…ˆä½¿ç”¨æœåŠ¡ç«¯ç»Ÿè®¡æ¥å£ï¼Œå¤±è´¥æ—¶é€€å›æœ¬åœ°ç»Ÿè®¡
      const url = '/api/views/hit?path=' + encodeURIComponent(key);
      try {
        fetch(url, { method: 'POST' })
          .then((resp) => {
            if (!resp.ok) throw new Error('bad status: ' + resp.status);
            return resp.json();
          })
          .then((data) => {
            if (!data || typeof data.count !== 'number') {
              updateLocalFallback();
              return;
            }
            el.textContent = String(data.count);
          })
          .catch(() => {
            updateLocalFallback();
          });
      } catch (e) {
        updateLocalFallback();
      }
    })();
    (function() {
      const article = document.querySelector('.post');
      const bar = document.getElementById('readingProgressBar');
      if (!article || !bar) return;
      const update = () => {
        const rect = article.getBoundingClientRect();
        const viewHeight = window.innerHeight || document.documentElement.clientHeight;
        const total = article.offsetHeight - viewHeight;
        if (total <= 0) {
          bar.style.width = '0%';
          return;
        }
        const scrolled = Math.min(Math.max(-rect.top, 0), total);
        const percent = (scrolled / total) * 100;
        bar.style.width = percent + '%';
      };
      window.addEventListener('scroll', update, { passive: true });
      window.addEventListener('resize', update);
      update();
    })();
    (function() {
      const toc = document.querySelector('.toc');
      const article = document.querySelector('.post .content');
      if (!toc || !article) return;
      const links = Array.from(toc.querySelectorAll('a[href^="#"]'));
      // æŠ˜å /å±•å¼€æ”¯æŒ
      toc.querySelectorAll('li').forEach((li) => {
        const sub = li.querySelector('ul');
        const link = li.querySelector('a');
        if (!sub || !link) return;
        li.classList.add('has-children');
      });
      const headings = links
        .map((link) => {
          const id = decodeURIComponent(link.getAttribute('href').slice(1));
          const h = article.querySelector('#' + CSS.escape(id));
          return h ? { el: h, link } : null;
        })
        .filter(Boolean);
      if (!headings.length) return;
      const setActive = (targetLink) => {
        links.forEach((a) => a.classList.toggle('is-active', a === targetLink));
      };
      if ('IntersectionObserver' in window) {
        const observer = new IntersectionObserver(
          (entries) => {
            let best = null;
            entries.forEach((entry) => {
              if (entry.isIntersecting) {
                if (!best || entry.target.offsetTop < best.target.offsetTop) {
                  best = entry;
                }
              }
            });
            if (best) {
              const id = best.target.id;
              const match = headings.find((h) => h.el.id === id);
              if (match) setActive(match.link);
            }
          },
          {
            rootMargin: '0px 0px -65%',
            threshold: [0, 1],
          }
        );
        headings.forEach(({ el }) => observer.observe(el));
      } else {
        const onScroll = () => {
          const top = window.scrollY || window.pageYOffset;
          let current = headings[0];
          headings.forEach((h) => {
            if (h.el.offsetTop - 80 <= top) current = h;
          });
          setActive(current.link);
        };
        window.addEventListener('scroll', onScroll, { passive: true });
        onScroll();
      }
    })();
    (function() {
      const article = document.querySelector('.post .content');
      if (!article) return;
      const pdfLinks = article.querySelectorAll('a[href$=".pdf"]');
      pdfLinks.forEach((a) => {
        a.target = '_blank';
        a.rel = 'noreferrer noopener';
        a.classList.add('pdf-link');
      });
    })();
    (function() {
      const blocks = document.querySelectorAll('.code-block');
      if (!blocks.length) return;
      blocks.forEach((block) => {
        if (block.dataset.hasLangLabel === 'true') return;
        const pre = block.querySelector('pre');
        if (!pre) return;
        const code = pre.querySelector('code');
        let lang = '';
        if (code) {
          if (code.dataset && code.dataset.lang) {
            lang = code.dataset.lang;
          } else {
            const cls = code.className || '';
            const m = cls.match(/language-([^\s]+)/);
            if (m) lang = m[1];
          }
        }
        if (!lang) return;
        let label = lang.toUpperCase();
        if (lang.toLowerCase() === 'cpp' || lang.toLowerCase() === 'c++') label = 'C++';
        if (lang.toLowerCase() === 'bash' || lang.toLowerCase() === 'sh' || lang.toLowerCase() === 'zsh') label = 'Bash';
        if (lang.toLowerCase() === 'python') label = 'Python';
        const badge = document.createElement('div');
        badge.className = 'code-lang';
        badge.textContent = label;
        block.insertBefore(badge, pre);
        block.dataset.hasLangLabel = 'true';
      });
    })();
    (function() {
      const btn = document.getElementById('backTopBtn');
      if (!btn) return;
      const threshold = 320;
      const onScroll = () => {
        const y = window.scrollY || window.pageYOffset;
        const shouldShow = y > threshold;
        btn.classList.toggle('is-visible', shouldShow);
      };
      btn.addEventListener('click', () => {
        window.scrollTo({ top: 0, behavior: 'smooth' });
      });
      window.addEventListener('scroll', onScroll, { passive: true });
      onScroll();
    })();
    (function() {
      const widget = document.getElementById('aiChatWidget');
      if (!widget) return;
      const toggle = document.getElementById('aiChatToggle');
      const panel = document.getElementById('aiChatPanel');
      const closeBtn = document.getElementById('aiChatClose');
      const form = document.getElementById('aiChatForm');
      const input = document.getElementById('aiChatInput');
      const body = document.getElementById('aiChatBody');
      const sendBtn = document.getElementById('aiChatSend');

      let isOpen = false;
      let sending = false;
      const history = [];

      const escapeHtml = (str) => {
        return str
          .replace(/&/g, '&amp;')
          .replace(/</g, '&lt;')
          .replace(/>/g, '&gt;')
          .replace(/"/g, '&quot;')
          .replace(/'/g, '&#39;');
      };

      const renderInlineMarkdown = (text) => {
        let out = escapeHtml(text);
        // é“¾æ¥ [text](url)
        out = out.replace(/\[([^\]]+)]\((https?:\/\/[^)]+)\)/g, '<a href="$2" target="_blank" rel="noreferrer noopener">$1</a>');
        // è¡Œå†…ä»£ç  `code`
        out = out.replace(/`([^`]+)`/g, '<code>$1</code>');
        // åŠ ç²— **text** æˆ– __text__
        out = out.replace(/\*\*([^*]+)\*\*/g, '<strong>$1</strong>');
        out = out.replace(/__([^_]+)__/g, '<strong>$1</strong>');
        return out;
      };

      const renderMarkdown = (text) => {
        const lines = text.split(/\r?\n/);
        const parts = [];
        let inCode = false;
        let codeLang = '';
        let codeLines = [];
        let inList = false;
        let listItems = '';

        const flushCode = () => {
          if (!inCode) return;
          const code = codeLines.join('\n');
          const cls = codeLang ? ` class="language-${codeLang}"` : '';
          parts.push(`<pre><code${cls}>${escapeHtml(code)}</code></pre>`);
          inCode = false;
          codeLang = '';
          codeLines = [];
        };

        const flushList = () => {
          if (!inList) return;
          parts.push(`<ul>${listItems}</ul>`);
          inList = false;
          listItems = '';
        };

        for (let raw of lines) {
          const line = raw.replace(/\s+$/, '');

          // ä»£ç å— ```lang
          const fenceMatch = line.match(/^```(\w+)?\s*$/);
          if (fenceMatch) {
            if (inCode) {
              flushCode();
            } else {
              flushList();
              inCode = true;
              codeLang = fenceMatch[1] || '';
              codeLines = [];
            }
            continue;
          }

          if (inCode) {
            codeLines.push(raw);
            continue;
          }

          const trimmed = line.trim();
          if (!trimmed) {
            flushList();
            continue;
          }

          // æ ‡é¢˜
          const headingMatch = trimmed.match(/^(#{1,6})\s+(.+)$/);
          if (headingMatch) {
            flushList();
            const level = headingMatch[1].length;
            const content = headingMatch[2];
            parts.push(`<h${level}>${renderInlineMarkdown(content)}</h${level}>`);
            continue;
          }

          // æ— åºåˆ—è¡¨
          const listMatch = trimmed.match(/^[-*]\s+(.+)$/);
          if (listMatch) {
            const item = renderInlineMarkdown(listMatch[1]);
            if (!inList) {
              inList = true;
              listItems = '';
            }
            listItems += `<li>${item}</li>`;
            continue;
          }

          // æ™®é€šæ®µè½
          flushList();
          parts.push(`<p>${renderInlineMarkdown(trimmed)}</p>`);
        }

        flushCode();
        flushList();
        return parts.join('\n');
      };

      const setOpen = (open) => {
        isOpen = open;
        panel.classList.toggle('is-open', open);
        panel.setAttribute('aria-hidden', open ? 'false' : 'true');
        if (open && input) {
          setTimeout(() => input.focus(), 80);
        }
      };

      const appendMessage = (role, text) => {
        if (!body) return;
        const wrapper = document.createElement('div');
        wrapper.className = 'ai-chat-message ' + (role === 'assistant' ? 'ai-chat-message-assistant' : 'ai-chat-message-user');
        const bubble = document.createElement('div');
        bubble.className = 'ai-chat-bubble';
        if (role === 'assistant') {
          bubble.innerHTML = renderMarkdown(text);
        } else {
          bubble.textContent = text;
        }
        wrapper.appendChild(bubble);
        body.appendChild(wrapper);
        body.scrollTop = body.scrollHeight;
      };

      const setSending = (v) => {
        sending = v;
        if (sendBtn) {
          sendBtn.disabled = v;
          sendBtn.textContent = v ? 'æ€è€ƒä¸­â€¦' : 'å‘é€';
        }
        if (input) {
          input.disabled = v;
        }
      };

      if (toggle) {
        toggle.addEventListener('click', () => {
          setOpen(!isOpen);
        });
      }
      if (closeBtn) {
        closeBtn.addEventListener('click', () => setOpen(false));
      }

      if (form && input) {
        form.addEventListener('submit', (e) => {
          e.preventDefault();
          if (sending) return;
          const text = input.value.trim();
          if (!text) return;
          appendMessage('user', text);
          history.push({ role: 'user', content: text });
          input.value = '';
          setSending(true);
          const host = window.location.hostname;
          const isLocal =
            host === 'localhost' ||
            host === '127.0.0.1' ||
            host === '0.0.0.0';
          const endpoint = isLocal
            ? 'http://127.0.0.1:9000/api/ai/chat'
            : '/api/ai/chat';
          fetch(endpoint, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ messages: history }),
          })
            .then((res) => {
              if (!res.ok) {
                throw new Error('HTTP ' + res.status);
              }
              return res.json();
            })
            .then((data) => {
              const reply = (data && data.reply) || 'ï¼ˆAI å“åº”ä¸ºç©ºï¼‰';
              history.push({ role: 'assistant', content: reply });
              appendMessage('assistant', reply);
            })
            .catch(() => {
              appendMessage('assistant', 'è°ƒç”¨ä¸ªäºº AI å¤±è´¥ï¼Œè¯·ç¨åé‡è¯•ï¼Œæˆ–æ£€æŸ¥åç«¯æœåŠ¡ / ç½‘ç»œè¿æ¥ã€‚');
            })
            .finally(() => {
              setSending(false);
            });
        });

        input.addEventListener('keydown', (e) => {
          if (e.key === 'Enter' && !e.shiftKey) {
            e.preventDefault();
            form.requestSubmit();
          }
        });
      }
    })();
    {{ if .Params.math }}
    if (typeof renderMathInElement === 'function') {
      const renderTarget = document.querySelector('.post .content') || document.body;
      renderMathInElement(renderTarget, {
        delimiters: [
          {left: "$$", right: "$$", display: true},
          {left: "$", right: "$", display: false},
          {left: "\\(", right: "\\)", display: false},
          {left: "\\[", right: "\\]", display: true}
        ],
        throwOnError: false,
        maxExpand: 1000,
        strict: 'ignore',
        ignoredTags: ['script', 'noscript', 'style', 'textarea']
      });
      try {
        const blocks = renderTarget.querySelectorAll('.katex-display');
        blocks.forEach((block) => {
          if (block.querySelector('.math-copy-btn')) return;
          const ann = block.querySelector('.katex-mathml annotation[encoding="application/x-tex"]');
          if (!ann) return;
          const tex = (ann.textContent || '').trim();
          if (!tex) return;
          const btn = document.createElement('button');
          btn.type = 'button';
          btn.className = 'math-copy-btn';
          btn.textContent = 'å¤åˆ¶';
          btn.addEventListener('click', (e) => {
            e.stopPropagation();
            const write = navigator.clipboard && navigator.clipboard.writeText
              ? navigator.clipboard.writeText(tex)
              : Promise.reject();
            write.then(() => {
              btn.textContent = 'å·²å¤åˆ¶';
              setTimeout(() => { btn.textContent = 'å¤åˆ¶'; }, 1200);
            }).catch(() => {
              try {
                const textarea = document.createElement('textarea');
                textarea.value = tex;
                document.body.appendChild(textarea);
                textarea.select();
                document.execCommand('copy');
                document.body.removeChild(textarea);
                btn.textContent = 'å·²å¤åˆ¶';
                setTimeout(() => { btn.textContent = 'å¤åˆ¶'; }, 1200);
              } catch (e) {}
            });
          });
          block.appendChild(btn);
        });
      } catch (e) {}
    }
    {{ end }}
  </script>
</body>
</html>
