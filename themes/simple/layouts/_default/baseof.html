{{ $styles := resources.Get "css/main.css" | toCSS | minify | fingerprint }}
<!DOCTYPE html>
<html lang="{{ site.Language.Lang }}">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>{{ if .IsHome }}{{ site.Title }}{{ else }}{{ .Title }} Â· {{ site.Title }}{{ end }}</title>
  {{/* åŠ¨æ€æè¿°ï¼šä¼˜å…ˆé¡µé¢ï¼Œå…¶æ¬¡æ‘˜è¦ï¼Œæœ€åç«™ç‚¹æè¿° */}}
  {{- $desc := "" -}}
  {{- with .Description -}}
    {{- $desc = . -}}
  {{- else -}}
    {{- with .Summary -}}
      {{- $desc = . | plainify | truncate 160 -}}
    {{- end -}}
  {{- end -}}
  {{- if not $desc -}}
    {{- with site.Params.description -}}
      {{- $desc = . -}}
    {{- end -}}
  {{- end -}}
  {{- if $desc }}<meta name="description" content="{{ $desc }}">{{ end }}
  {{- with .Params.tags }}
    <meta name="keywords" content="{{ delimit . ", " }}">
  {{- end }}
  {{- $canonical := .Permalink -}}
  {{- if .IsHome -}}
    {{- $canonical = site.BaseURL -}}
  {{- end -}}
  <link rel="canonical" href="{{ $canonical }}">
  {{- $image := "" -}}
  {{- with .Params.cover -}}
    {{- $image = . | relURL | absURL -}}
  {{- else -}}
    {{- with .Resources.ByType "image" -}}
      {{- with .GetMatch "*" -}}
        {{- $image = .RelPermalink | absURL -}}
      {{- end -}}
    {{- end -}}
  {{- end -}}
  {{- if not $image -}}
    {{- $imgs := findRE "<img[^>]+src=\\\"([^\\\"]+)\\\"" .Content 1 -}}
    {{- if gt (len $imgs) 0 -}}
      {{- $m := index $imgs 0 -}}
      {{- $srcMatch := findRE "src=\\\"([^\\\"]+)\\\"" $m 1 -}}
      {{- if gt (len $srcMatch) 0 -}}
        {{- $raw := index $srcMatch 0 -}}
        {{- $src := replace (replace $raw "src=\"" "") "\"" "" -}}
        {{- $image = $src | relURL | absURL -}}
      {{- end -}}
    {{- end -}}
  {{- end -}}
  {{- if not $image -}}
    {{- $image = "/avatar.png" | relURL | absURL -}}
  {{- end -}}
  <meta property="og:type" content="{{ if .IsHome }}website{{ else }}article{{ end }}">
  <meta property="og:site_name" content="{{ site.Title }}">
  <meta property="og:title" content="{{ if .IsHome }}{{ site.Title }}{{ else }}{{ .Title }} Â· {{ site.Title }}{{ end }}">
  {{- if $desc }}<meta property="og:description" content="{{ $desc }}">{{ end }}
  <meta property="og:url" content="{{ $canonical }}">
  <meta property="og:image" content="{{ $image }}">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:title" content="{{ if .IsHome }}{{ site.Title }}{{ else }}{{ .Title }} Â· {{ site.Title }}{{ end }}">
  {{- if $desc }}<meta name="twitter:description" content="{{ $desc }}">{{ end }}
  <meta name="twitter:image" content="{{ $image }}">
  {{ if .IsHome }}
    <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "Person",
      "name": "Yiqian Gong",
      "alternateName": "CodeAlan",
      "url": "{{ site.BaseURL }}",
      "sameAs": [
        "https://github.com/CodeAlanqian",
        "https://space.bilibili.com/352156963"
      ]
    }
    </script>
  {{ end }}
  <link rel="icon" href="{{ "/avatar.png" | relURL }}" type="image/png">
  <link rel="stylesheet" href="{{ $styles.RelPermalink }}" integrity="{{ $styles.Data.Integrity }}">
  {{ if .Params.math }}
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.css">
  {{ end }}
</head>
<body class="no-js{{ if .IsHome }} home{{ end }}{{ if eq .RelPermalink "/academic/" }} page-academic{{ end }}">
  <header class="site-header">
    <div class="brand">
      <a href="{{ "/" | relURL }}">{{ site.Title }}</a>
      {{ with site.Params.description }}<p class="tagline">{{ . }}</p>{{ end }}
    </div>
    <div class="header-actions">
      {{ if not .IsHome }}
        <button class="back-btn" id="backBtn" aria-label="è¿”å›ä¸Šä¸€çº§" type="button">
          <span aria-hidden="true">â†</span>
          <span class="back-label">è¿”å›</span>
        </button>
      {{ end }}
      <button class="theme-toggle" id="themeToggle" aria-label="åˆ‡æ¢ä¸»é¢˜" type="button">â˜€ï¸</button>
      {{ $searchMenu := where site.Menus.main "Name" "==" "æœç´¢" }}
      {{ with index $searchMenu 0 }}
        <a href="{{ .URL }}" class="search-icon"
           aria-label="æœç´¢">
          <span aria-hidden="true">ğŸ”</span>
          <span class="sr-only">æœç´¢</span>
        </a>
      {{ end }}
      <nav class="site-nav">
        {{ range site.Menus.main }}
          {{ if ne .Name "æœç´¢" }}
            <a href="{{ .URL }}" {{ if $.IsMenuCurrent "main" . }}aria-current="page"{{ end }}>{{ .Name }}</a>
          {{ end }}
        {{ end }}
      </nav>
    </div>
  </header>
  <div class="reading-progress" aria-hidden="true">
    <div class="reading-progress-bar" id="readingProgressBar"></div>
  </div>
  <main class="site-main">
    {{ block "main" . }}{{ end }}
  </main>
  {{ partial "ai-chat.html" . }}
  <button class="back-top" id="backTopBtn" type="button" aria-label="å›åˆ°é¡¶éƒ¨">â†‘</button>
  <footer class="site-footer">
    <p>Â© {{ now.Format "2006" }} CodeAlan Â· Powered by Hugo</p>
    <p><a href="https://beian.miit.gov.cn" target="_blank" rel="noreferrer">ç²¤ICPå¤‡2023012271å·-1</a></p>
  </footer>
  {{ if .Params.math }}
    <script src="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/contrib/auto-render.min.js"></script>
  {{ end }}
  <script>
    (function() {
      const root = document.documentElement;
      const body = document.body;
      const toggle = document.getElementById('themeToggle');
      const storageKey = 'theme';
      const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
      const saved = localStorage.getItem(storageKey);
      const initial = saved || (prefersDark ? 'dark' : 'light');
      const apply = (mode) => {
        if (mode === 'dark') {
          root.classList.add('dark');
          toggle.textContent = 'ğŸŒ™';
        } else {
          root.classList.remove('dark');
          toggle.textContent = 'â˜€ï¸';
        }
        localStorage.setItem(storageKey, mode);
      };
      body.classList.remove('no-js');
      apply(initial);
      if (toggle) {
        toggle.addEventListener('click', () => {
          const next = root.classList.contains('dark') ? 'light' : 'dark';
          apply(next);
        });
      }
    })();
    (function() {
      const isTypingTarget = (el) => {
        if (!el) return false;
        const tag = el.tagName;
        const editable = el.isContentEditable;
        return editable ||
          tag === 'INPUT' ||
          tag === 'TEXTAREA' ||
          tag === 'SELECT';
      };
      document.addEventListener('keydown', (e) => {
        if (e.defaultPrevented) return;
        if (isTypingTarget(e.target)) return;
        if (e.key === '/' && !e.metaKey && !e.ctrlKey && !e.altKey && !e.altKey) {
          const search = document.getElementById('searchInput');
          if (search) {
            e.preventDefault();
            search.focus();
            search.select();
          } else {
            window.location.href = '{{ "/search/" | relURL }}';
          }
        }
        if (e.key === 't' && !e.metaKey && !e.ctrlKey && !e.altKey) {
          e.preventDefault();
          window.scrollTo({ top: 0, behavior: 'smooth' });
        }
        if ((e.key === 'j' || e.key === 'k') && !e.metaKey && !e.ctrlKey && !e.altKey) {
          const prev = document.querySelector('.post-nav-link.prev');
          const next = document.querySelector('.post-nav-link.next');
          if (e.key === 'j' && next) {
            window.location.href = next.getAttribute('href');
          } else if (e.key === 'k' && prev) {
            window.location.href = prev.getAttribute('href');
          }
        }
      });
    })();
    (function() {
      const backBtn = document.getElementById('backBtn');
      if (!backBtn) return;
      backBtn.addEventListener('click', () => {
        if (window.history.length > 1) {
          window.history.back();
        } else {
          window.location.href = '{{ "/" | relURL }}';
        }
      });
    })();
    (function() {
      const buttons = document.querySelectorAll('.copy-btn');
      buttons.forEach((btn) => {
        btn.addEventListener('click', () => {
          const pre = btn.nextElementSibling;
          if (!pre) return;
          const codeEl = pre.querySelector('code') || pre;
          const text = codeEl.textContent;
          const write = navigator.clipboard && navigator.clipboard.writeText
            ? navigator.clipboard.writeText(text)
            : Promise.reject();
          write.then(() => {
            btn.textContent = 'å·²å¤åˆ¶';
            setTimeout(() => (btn.textContent = 'å¤åˆ¶'), 1200);
          }).catch(() => {
            try {
              const textarea = document.createElement('textarea');
              textarea.value = text;
              document.body.appendChild(textarea);
              textarea.select();
              document.execCommand('copy');
              document.body.removeChild(textarea);
              btn.textContent = 'å·²å¤åˆ¶';
              setTimeout(() => (btn.textContent = 'å¤åˆ¶'), 1200);
            } catch (e) {}
          });
        });
      });
    })();
    (function() {
      const article = document.querySelector('.post .content');
      if (!article) return;
      const headings = article.querySelectorAll('h2[id], h3[id], h4[id]');
      headings.forEach((h) => {
        const id = h.id;
        if (!id) return;
        const anchor = document.createElement('button');
        anchor.type = 'button';
        anchor.className = 'heading-anchor';
        anchor.textContent = '#';
        anchor.addEventListener('click', (e) => {
          e.stopPropagation();
          const url = window.location.origin + window.location.pathname + '#' + id;
          const write = navigator.clipboard && navigator.clipboard.writeText
            ? navigator.clipboard.writeText(url)
            : Promise.reject();
          write.then(() => {
            anchor.textContent = 'å·²å¤åˆ¶';
            setTimeout(() => (anchor.textContent = '#'), 1200);
          }).catch(() => {
            try {
              const textarea = document.createElement('textarea');
              textarea.value = url;
              document.body.appendChild(textarea);
              textarea.select();
              document.execCommand('copy');
              document.body.removeChild(textarea);
              anchor.textContent = 'å·²å¤åˆ¶';
              setTimeout(() => (anchor.textContent = '#'), 1200);
            } catch (e) {}
          });
        });
        h.appendChild(anchor);
      });
    })();
    (function() {
      const btn = document.getElementById('postShareBtn');
      if (!btn || typeof window === 'undefined') return;
      btn.addEventListener('click', () => {
        const url = window.location.href;
        const write = navigator.clipboard && navigator.clipboard.writeText
          ? navigator.clipboard.writeText(url)
          : Promise.reject();
        write.then(() => {
          btn.textContent = 'å·²å¤åˆ¶é“¾æ¥';
          setTimeout(() => (btn.textContent = 'å¤åˆ¶æœ¬é¡µé“¾æ¥'), 1200);
        }).catch(() => {
          try {
            const textarea = document.createElement('textarea');
            textarea.value = url;
            document.body.appendChild(textarea);
            textarea.select();
            document.execCommand('copy');
            document.body.removeChild(textarea);
            btn.textContent = 'å·²å¤åˆ¶é“¾æ¥';
            setTimeout(() => (btn.textContent = 'å¤åˆ¶æœ¬é¡µé“¾æ¥'), 1200);
          } catch (e) {}
        });
      });
    })();
    (function() {
      const likeBtn = document.getElementById('postLikeBtn');
      const likeCountEl = document.getElementById('postLikeCount');
      const donateBtn = document.getElementById('postDonateBtn');
      const donatePopup = document.getElementById('postDonatePopup');
      if (!likeBtn && !donateBtn) return;
      const path = window.location.pathname || '/';
      const likeKey = 'like:' + path;

      const updateLikeCount = (count) => {
        if (likeCountEl && typeof count === 'number' && !Number.isNaN(count)) {
          likeCountEl.textContent = String(count);
        }
      };

      if (likeBtn && likeCountEl) {
        const liked = !!localStorage.getItem(likeKey);
        if (liked) {
          likeBtn.classList.add('is-liked');
        }
        fetch('/api/likes/get?path=' + encodeURIComponent(path))
          .then((res) => (res.ok ? res.json() : null))
          .then((data) => {
            if (data && typeof data.count === 'number') {
              updateLikeCount(data.count);
            }
          })
          .catch(() => {});

        likeBtn.addEventListener('click', () => {
          if (likeBtn.classList.contains('is-liked')) return;
          likeBtn.classList.add('is-liked');
          localStorage.setItem(likeKey, '1');
          fetch('/api/likes/hit?path=' + encodeURIComponent(path), { method: 'POST' })
            .then((res) => (res.ok ? res.json() : null))
            .then((data) => {
              if (data && typeof data.count === 'number') {
                updateLikeCount(data.count);
              }
            })
            .catch(() => {
              const current = parseInt(likeCountEl.textContent || '0', 10) || 0;
              updateLikeCount(current + 1);
            });
        });
      }

      if (donateBtn && donatePopup) {
        donateBtn.addEventListener('click', () => {
          donatePopup.classList.toggle('is-open');
        });
      }
    })();
    (function() {
      const btn = document.getElementById('postPptBtn');
      if (!btn) return;
      const content = document.querySelector('.post .content');
      if (!content) return;
      btn.addEventListener('click', () => {
        const blocks = Array.from(content.children);
        const slides = [];
        let current = null;
        blocks.forEach((node) => {
          if (node.matches && node.matches('h2, h3')) {
            current = { title: node.textContent || '', nodes: [] };
            slides.push(current);
          } else if (current) {
            current.nodes.push(node.cloneNode(true));
          }
        });
        if (!slides.length) {
          current = { title: document.title, nodes: [content.cloneNode(true)] };
          slides.push(current);
        }
        const overlay = document.createElement('div');
        overlay.className = 'ppt-overlay';
        overlay.dataset.pptActive = 'true';
        const header = document.createElement('div');
        header.className = 'ppt-header';
        const titleEl = document.createElement('div');
        titleEl.textContent = document.title;
        const closeBtn = document.createElement('button');
        closeBtn.type = 'button';
        closeBtn.className = 'ppt-btn';
        closeBtn.textContent = 'é€€å‡º';
        header.appendChild(titleEl);
        header.appendChild(closeBtn);
        const body = document.createElement('div');
        body.className = 'ppt-body';
        const footer = document.createElement('div');
        footer.className = 'ppt-footer';
        const hint = document.createElement('div');
        hint.textContent = 'â† / â†’ åˆ‡æ¢ä¸Šä¸€é¡µ/ä¸‹ä¸€é¡µ Â· Esc é€€å‡º';
        const controls = document.createElement('div');
        controls.className = 'ppt-controls';
        const prevBtn = document.createElement('button');
        prevBtn.type = 'button';
        prevBtn.className = 'ppt-btn';
        prevBtn.textContent = 'ä¸Šä¸€é¡µ';
        const nextBtn = document.createElement('button');
        nextBtn.type = 'button';
        nextBtn.className = 'ppt-btn';
        nextBtn.textContent = 'ä¸‹ä¸€é¡µ';
        controls.appendChild(prevBtn);
        controls.appendChild(nextBtn);
        footer.appendChild(hint);
        footer.appendChild(controls);
        overlay.appendChild(header);
        overlay.appendChild(body);
        overlay.appendChild(footer);
        const slideEls = slides.map((slide, idx) => {
          const el = document.createElement('div');
          el.className = 'ppt-slide';
          const h = document.createElement('h2');
          h.textContent = slide.title || ('Slide ' + (idx + 1));
          el.appendChild(h);
          slide.nodes.forEach((node) => el.appendChild(node));
          body.appendChild(el);
          return el;
        });
        let index = 0;
        const update = () => {
          slideEls.forEach((el, i) => {
            el.classList.toggle('is-active', i === index);
          });
        };
        const cleanup = () => {
          if (overlay.parentNode) {
            document.body.removeChild(overlay);
          }
          document.removeEventListener('keydown', onKey);
        };
        const onKey = (e) => {
          if (e.key === 'Escape') {
            e.preventDefault();
            cleanup();
          } else if (e.key === 'ArrowRight' || e.key === 'PageDown' || e.key === ' ') {
            e.preventDefault();
            if (index < slideEls.length - 1) {
              index += 1;
              update();
            }
          } else if (e.key === 'ArrowLeft' || e.key === 'PageUp') {
            e.preventDefault();
            if (index > 0) {
              index -= 1;
              update();
            }
          }
        };
        prevBtn.addEventListener('click', () => {
          if (index > 0) {
            index -= 1;
            update();
          }
        });
        nextBtn.addEventListener('click', () => {
          if (index < slideEls.length - 1) {
            index += 1;
            update();
          }
        });
        closeBtn.addEventListener('click', cleanup);
        document.addEventListener('keydown', onKey);
        document.body.appendChild(overlay);
        index = 0;
        update();
      });
    })();
    (function() {
      const article = document.querySelector('.post .content');
      if (!article) return;
      const imgs = article.querySelectorAll('img');
      if (!imgs.length) return;
      imgs.forEach((img) => {
        img.style.cursor = 'zoom-in';
        img.addEventListener('click', () => {
          if (img.dataset.noLightbox === 'true') return;
          const overlay = document.createElement('div');
          overlay.className = 'lightbox-overlay';
          const big = document.createElement('img');
          big.src = img.src;
          big.alt = img.alt || '';
          overlay.appendChild(big);
          overlay.addEventListener('click', (e) => {
            if (e.target === overlay) {
              document.body.removeChild(overlay);
            }
          });
          document.addEventListener('keydown', function onKey(ev) {
            if (ev.key === 'Escape') {
              if (overlay.parentNode) {
                document.body.removeChild(overlay);
              }
              document.removeEventListener('keydown', onKey);
            }
          });
          document.body.appendChild(overlay);
        });
      });
      // ä¸ºç¼ºå°‘è¯´æ˜çš„å›¾ç‰‡æ·»åŠ ç®€çŸ­å ä½è¯´æ˜ï¼ˆä¸ä¿®æ”¹åŸå§‹å†…å®¹ï¼‰
      imgs.forEach((img) => {
        // å·²æœ‰ alt æˆ– title æˆ–åœ¨ figure å†…å¸¦ figcaption çš„å›¾ç‰‡è·³è¿‡
        if ((img.alt && img.alt.trim()) || (img.title && img.title.trim())) return;
        const parentFigure = img.closest('figure');
        if (parentFigure && parentFigure.querySelector('figcaption')) return;
        let hint = '';
        try {
          const src = img.getAttribute('src') || '';
          if (src) {
            const parts = src.split('/');
            const file = parts[parts.length - 1] || '';
            const base = file.split('.')[0] || '';
            if (base) {
              hint = decodeURIComponent(base)
                .replace(/[-_]+/g, ' ')
                .trim();
            }
          }
        } catch (e) {}
        if (!hint) {
          hint = 'è‡ªåŠ¨ç”Ÿæˆçš„å›¾ç‰‡è¯´æ˜';
        }
        const caption = document.createElement('div');
        caption.className = 'auto-img-caption';
        caption.textContent = hint;
        const wrapper = parentFigure || img.parentElement;
        if (wrapper) {
          wrapper.appendChild(caption);
        } else {
          img.insertAdjacentElement('afterend', caption);
        }
      });
    })();
    (function() {
      const el = document.querySelector('.view-count');
      if (!el || typeof window === 'undefined') return;
      const key = el.getAttribute('data-key') || window.location.pathname;

      const updateLocalFallback = () => {
        if (!window.localStorage) return;
        const storageKey = 'views:' + key;
        let count = 0;
        try {
          const raw = localStorage.getItem(storageKey);
          if (raw) count = parseInt(raw, 10) || 0;
        } catch (e) {}
        count += 1;
        el.textContent = count;
        try {
          localStorage.setItem(storageKey, String(count));
        } catch (e) {}
      };

      // ä¼˜å…ˆä½¿ç”¨æœåŠ¡ç«¯ç»Ÿè®¡æ¥å£ï¼Œå¤±è´¥æ—¶é€€å›æœ¬åœ°ç»Ÿè®¡
      const url = '/api/views/hit?path=' + encodeURIComponent(key);
      try {
        fetch(url, { method: 'POST' })
          .then((resp) => {
            if (!resp.ok) throw new Error('bad status: ' + resp.status);
            return resp.json();
          })
          .then((data) => {
            if (!data || typeof data.count !== 'number') {
              updateLocalFallback();
              return;
            }
            el.textContent = String(data.count);
          })
          .catch(() => {
            updateLocalFallback();
          });
      } catch (e) {
        updateLocalFallback();
      }
    })();
    (function() {
      const article = document.querySelector('.post');
      const bar = document.getElementById('readingProgressBar');
      if (!article || !bar) return;
      const update = () => {
        const rect = article.getBoundingClientRect();
        const viewHeight = window.innerHeight || document.documentElement.clientHeight;
        const total = article.offsetHeight - viewHeight;
        if (total <= 0) {
          bar.style.width = '0%';
          return;
        }
        const scrolled = Math.min(Math.max(-rect.top, 0), total);
        const percent = (scrolled / total) * 100;
        bar.style.width = percent + '%';
      };
      window.addEventListener('scroll', update, { passive: true });
      window.addEventListener('resize', update);
      update();
    })();
    (function() {
      const toc = document.querySelector('.toc');
      const article = document.querySelector('.post .content');
      if (!toc || !article) return;
      const links = Array.from(toc.querySelectorAll('a[href^="#"]'));
      // æŠ˜å /å±•å¼€æ”¯æŒ
      toc.querySelectorAll('li').forEach((li) => {
        const sub = li.querySelector('ul');
        const link = li.querySelector('a');
        if (!sub || !link) return;
        li.classList.add('has-children');
      });
      const headings = links
        .map((link) => {
          const id = decodeURIComponent(link.getAttribute('href').slice(1));
          const h = article.querySelector('#' + CSS.escape(id));
          return h ? { el: h, link } : null;
        })
        .filter(Boolean);
      if (!headings.length) return;
      const setActive = (targetLink) => {
        links.forEach((a) => a.classList.toggle('is-active', a === targetLink));
      };
      if ('IntersectionObserver' in window) {
        const observer = new IntersectionObserver(
          (entries) => {
            let best = null;
            entries.forEach((entry) => {
              if (entry.isIntersecting) {
                if (!best || entry.target.offsetTop < best.target.offsetTop) {
                  best = entry;
                }
              }
            });
            if (best) {
              const id = best.target.id;
              const match = headings.find((h) => h.el.id === id);
              if (match) setActive(match.link);
            }
          },
          {
            rootMargin: '0px 0px -65%',
            threshold: [0, 1],
          }
        );
        headings.forEach(({ el }) => observer.observe(el));
      } else {
        const onScroll = () => {
          const top = window.scrollY || window.pageYOffset;
          let current = headings[0];
          headings.forEach((h) => {
            if (h.el.offsetTop - 80 <= top) current = h;
          });
          setActive(current.link);
        };
        window.addEventListener('scroll', onScroll, { passive: true });
        onScroll();
      }
    })();
    (function() {
      const article = document.querySelector('.post .content');
      if (!article) return;
      const pdfLinks = article.querySelectorAll('a[href$=".pdf"]');
      pdfLinks.forEach((a) => {
        a.target = '_blank';
        a.rel = 'noreferrer noopener';
        a.classList.add('pdf-link');
      });
    })();
    (function() {
      const blocks = document.querySelectorAll('.code-block');
      if (!blocks.length) return;
      blocks.forEach((block) => {
        if (block.dataset.hasLangLabel === 'true') return;
        const pre = block.querySelector('pre');
        if (!pre) return;
        const code = pre.querySelector('code');
        let lang = '';
        if (code) {
          if (code.dataset && code.dataset.lang) {
            lang = code.dataset.lang;
          } else {
            const cls = code.className || '';
            const m = cls.match(/language-([^\s]+)/);
            if (m) lang = m[1];
          }
        }
        if (!lang) return;
        let label = lang.toUpperCase();
        if (lang.toLowerCase() === 'cpp' || lang.toLowerCase() === 'c++') label = 'C++';
        if (lang.toLowerCase() === 'bash' || lang.toLowerCase() === 'sh' || lang.toLowerCase() === 'zsh') label = 'Bash';
        if (lang.toLowerCase() === 'python') label = 'Python';
        const badge = document.createElement('div');
        badge.className = 'code-lang';
        badge.textContent = label;
        block.insertBefore(badge, pre);
        block.dataset.hasLangLabel = 'true';
      });
    })();
    (function() {
      const blocks = document.querySelectorAll('.code-block');
      if (!blocks.length) return;
      const maxCollapsed = 220;
      blocks.forEach((block) => {
        if (block.dataset.hasCodeToggle === 'true') return;
        const pre = block.querySelector('pre');
        if (!pre) return;
        const scrollHeight = pre.scrollHeight || 0;
        if (scrollHeight <= maxCollapsed) return;
        block.classList.add('collapsed');
        const toggle = document.createElement('button');
        toggle.type = 'button';
        toggle.className = 'code-toggle';
        toggle.textContent = 'Show code';
        toggle.addEventListener('click', () => {
          const collapsed = block.classList.toggle('collapsed');
          toggle.textContent = collapsed ? 'Show code' : 'Hide code';
        });
        block.parentNode.insertBefore(toggle, block.nextSibling);
        block.dataset.hasCodeToggle = 'true';
      });
    })();
    (function() {
      const btn = document.getElementById('backTopBtn');
      if (!btn) return;
      const threshold = 320;
      const onScroll = () => {
        const y = window.scrollY || window.pageYOffset;
        const shouldShow = y > threshold;
        btn.classList.toggle('is-visible', shouldShow);
      };
      btn.addEventListener('click', () => {
        window.scrollTo({ top: 0, behavior: 'smooth' });
      });
      window.addEventListener('scroll', onScroll, { passive: true });
      onScroll();
    })();
    (function() {
      const widget = document.getElementById('aiChatWidget');
      if (!widget) return;
      const toggle = document.getElementById('aiChatToggle');
      const panel = document.getElementById('aiChatPanel');
      const closeBtn = document.getElementById('aiChatClose');
      const form = document.getElementById('aiChatForm');
      const input = document.getElementById('aiChatInput');
      const body = document.getElementById('aiChatBody');
      const sendBtn = document.getElementById('aiChatSend');

      let isOpen = false;
      let sending = false;
      const history = [];

      const escapeHtml = (str) => {
        return str
          .replace(/&/g, '&amp;')
          .replace(/</g, '&lt;')
          .replace(/>/g, '&gt;')
          .replace(/"/g, '&quot;')
          .replace(/'/g, '&#39;');
      };

      const renderInlineMarkdown = (text) => {
        let out = escapeHtml(text);
        // é“¾æ¥ [text](url)
        out = out.replace(/\[([^\]]+)]\((https?:\/\/[^)]+)\)/g, '<a href="$2" target="_blank" rel="noreferrer noopener">$1</a>');
        // è¡Œå†…ä»£ç  `code`
        out = out.replace(/`([^`]+)`/g, '<code>$1</code>');
        // åŠ ç²— **text** æˆ– __text__
        out = out.replace(/\*\*([^*]+)\*\*/g, '<strong>$1</strong>');
        out = out.replace(/__([^_]+)__/g, '<strong>$1</strong>');
        return out;
      };

      const renderMarkdown = (text) => {
        const lines = text.split(/\r?\n/);
        const parts = [];
        let inCode = false;
        let codeLang = '';
        let codeLines = [];
        let inList = false;
        let listItems = '';

        const flushCode = () => {
          if (!inCode) return;
          const code = codeLines.join('\n');
          const cls = codeLang ? ` class="language-${codeLang}"` : '';
          parts.push(`<pre><code${cls}>${escapeHtml(code)}</code></pre>`);
          inCode = false;
          codeLang = '';
          codeLines = [];
        };

        const flushList = () => {
          if (!inList) return;
          parts.push(`<ul>${listItems}</ul>`);
          inList = false;
          listItems = '';
        };

        for (let raw of lines) {
          const line = raw.replace(/\s+$/, '');

          // ä»£ç å— ```lang
          const fenceMatch = line.match(/^```(\w+)?\s*$/);
          if (fenceMatch) {
            if (inCode) {
              flushCode();
            } else {
              flushList();
              inCode = true;
              codeLang = fenceMatch[1] || '';
              codeLines = [];
            }
            continue;
          }

          if (inCode) {
            codeLines.push(raw);
            continue;
          }

          const trimmed = line.trim();
          if (!trimmed) {
            flushList();
            continue;
          }

          // æ ‡é¢˜
          const headingMatch = trimmed.match(/^(#{1,6})\s+(.+)$/);
          if (headingMatch) {
            flushList();
            const level = headingMatch[1].length;
            const content = headingMatch[2];
            parts.push(`<h${level}>${renderInlineMarkdown(content)}</h${level}>`);
            continue;
          }

          // æ— åºåˆ—è¡¨
          const listMatch = trimmed.match(/^[-*]\s+(.+)$/);
          if (listMatch) {
            const item = renderInlineMarkdown(listMatch[1]);
            if (!inList) {
              inList = true;
              listItems = '';
            }
            listItems += `<li>${item}</li>`;
            continue;
          }

          // æ™®é€šæ®µè½
          flushList();
          parts.push(`<p>${renderInlineMarkdown(trimmed)}</p>`);
        }

        flushCode();
        flushList();
        return parts.join('\n');
      };

      const setOpen = (open) => {
        isOpen = open;
        panel.classList.toggle('is-open', open);
        panel.setAttribute('aria-hidden', open ? 'false' : 'true');
        if (open && input) {
          setTimeout(() => input.focus(), 80);
        }
      };

      const appendMessage = (role, text) => {
        if (!body) return;
        const wrapper = document.createElement('div');
        wrapper.className = 'ai-chat-message ' + (role === 'assistant' ? 'ai-chat-message-assistant' : 'ai-chat-message-user');
        const bubble = document.createElement('div');
        bubble.className = 'ai-chat-bubble';
        if (role === 'assistant') {
          bubble.innerHTML = renderMarkdown(text);
        } else {
          bubble.textContent = text;
        }
        wrapper.appendChild(bubble);
        body.appendChild(wrapper);
        body.scrollTop = body.scrollHeight;
      };

      const setSending = (v) => {
        sending = v;
        if (sendBtn) {
          sendBtn.disabled = v;
          sendBtn.textContent = v ? 'æ€è€ƒä¸­â€¦' : 'å‘é€';
        }
        if (input) {
          input.disabled = v;
        }
      };

      if (toggle) {
        toggle.addEventListener('click', () => {
          setOpen(!isOpen);
        });
      }
      if (closeBtn) {
        closeBtn.addEventListener('click', () => setOpen(false));
      }

      if (form && input) {
        form.addEventListener('submit', (e) => {
          e.preventDefault();
          if (sending) return;
          const text = input.value.trim();
          if (!text) return;
          appendMessage('user', text);
          history.push({ role: 'user', content: text });
          input.value = '';
          setSending(true);
          const host = window.location.hostname;
          const isLocal =
            host === 'localhost' ||
            host === '127.0.0.1' ||
            host === '0.0.0.0';
          const endpoint = isLocal
            ? 'http://127.0.0.1:9000/api/ai/chat'
            : '/api/ai/chat';
          fetch(endpoint, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ messages: history }),
          })
            .then((res) => {
              if (!res.ok) {
                throw new Error('HTTP ' + res.status);
              }
              return res.json();
            })
            .then((data) => {
              const reply = (data && data.reply) || 'ï¼ˆAI å“åº”ä¸ºç©ºï¼‰';
              history.push({ role: 'assistant', content: reply });
              appendMessage('assistant', reply);
            })
            .catch(() => {
              appendMessage('assistant', 'è°ƒç”¨ä¸ªäºº AI å¤±è´¥ï¼Œè¯·ç¨åé‡è¯•ï¼Œæˆ–æ£€æŸ¥åç«¯æœåŠ¡ / ç½‘ç»œè¿æ¥ã€‚');
            })
            .finally(() => {
              setSending(false);
            });
        });

        input.addEventListener('keydown', (e) => {
          if (e.key === 'Enter' && !e.shiftKey) {
            e.preventDefault();
            form.requestSubmit();
          }
        });
      }
    })();
    (function() {
      const btn = document.getElementById('readingModeFab');
      if (!btn) return;
      const root = document.documentElement;
      const key = 'reading-mode';
      const apply = (on) => {
        root.classList.toggle('reading-mode', on);
        btn.textContent = on ? 'é€€' : 'é˜…';
      };
      btn.addEventListener('click', () => {
        const next = !root.classList.contains('reading-mode');
        apply(next);
        try {
          localStorage.setItem(key, next ? '1' : '0');
        } catch (e) {}
      });
      try {
        const saved = localStorage.getItem(key);
        if (saved === '1') apply(true);
      } catch (e) {}
    })();
    {{ if .Params.math }}
    if (typeof renderMathInElement === 'function') {
      const renderTarget = document.querySelector('.post .content') || document.body;
      renderMathInElement(renderTarget, {
        delimiters: [
          {left: "$$", right: "$$", display: true},
          {left: "$", right: "$", display: false},
          {left: "\\(", right: "\\)", display: false},
          {left: "\\[", right: "\\]", display: true}
        ],
        throwOnError: false,
        maxExpand: 1000,
        strict: 'ignore',
        ignoredTags: ['script', 'noscript', 'style', 'textarea']
      });
      try {
        const blocks = renderTarget.querySelectorAll('.katex-display');
        blocks.forEach((block) => {
          if (block.querySelector('.math-copy-btn')) return;
          const ann = block.querySelector('.katex-mathml annotation[encoding="application/x-tex"]');
          if (!ann) return;
          const tex = (ann.textContent || '').trim();
          if (!tex) return;
          const btn = document.createElement('button');
          btn.type = 'button';
          btn.className = 'math-copy-btn';
          btn.textContent = 'å¤åˆ¶';
          btn.addEventListener('click', (e) => {
            e.stopPropagation();
            const write = navigator.clipboard && navigator.clipboard.writeText
              ? navigator.clipboard.writeText(tex)
              : Promise.reject();
            write.then(() => {
              btn.textContent = 'å·²å¤åˆ¶';
              setTimeout(() => { btn.textContent = 'å¤åˆ¶'; }, 1200);
            }).catch(() => {
              try {
                const textarea = document.createElement('textarea');
                textarea.value = tex;
                document.body.appendChild(textarea);
                textarea.select();
                document.execCommand('copy');
                document.body.removeChild(textarea);
                btn.textContent = 'å·²å¤åˆ¶';
                setTimeout(() => { btn.textContent = 'å¤åˆ¶'; }, 1200);
              } catch (e) {}
            });
          });
          block.appendChild(btn);
        });
      } catch (e) {}
    }
    {{ end }}
  </script>
</body>
</html>
