{{ define "main" }}
  {{ $kind := .Data.Singular }}
  {{ $isTag := eq $kind "tag" }}
  {{ $isSeries := eq $kind "series" }}
  <section class="hero">
    <p class="eyebrow">{{ if $isTag }}标签{{ else if $isSeries }}专栏{{ else }}分类{{ end }}</p>
    <h1>{{ if $isTag }}全部标签{{ else if $isSeries }}全部专栏{{ else }}全部分类{{ end }}</h1>
    <p class="lede">共 {{ len .Data.Terms }} 个{{ if $isTag }}标签{{ else if $isSeries }}专栏{{ else }}分类{{ end }}</p>
  </section>
  <section class="tag-cloud-list">
    {{ range $name, $term := .Data.Terms }}
      <a class="tag-pill tag-cloud-item" href="{{ $term.Page.RelPermalink }}">
        <span class="tag-name">{{ $name }}</span>
        <span class="tag-count">{{ $term.Count }}</span>
      </a>
    {{ end }}
  </section>
  {{ if $isTag }}
    {{/* 构造简单的标签共现数据，供前端绘制知识图谱使用 */}}
    {{- $pages := where site.RegularPages "Type" "in" (slice "posts" "obsidian") -}}
    {{- $items := slice -}}
    {{- range $p := $pages -}}
      {{- $obj := dict "tags" ($p.Params.tags | default (slice)) -}}
      {{- $items = $items | append $obj -}}
    {{- end -}}
    <section class="tag-graph">
      <h2>标签知识图谱</h2>
      <p class="tag-graph-hint">根据文章中标签共现关系绘制，仅展示出现频率较高的部分标签。</p>
      <div id="tagGraph"></div>
      <script>
        (function() {
          const container = document.getElementById('tagGraph');
          if (!container) return;
          const pages = JSON.parse({{ $items | jsonify }});
          const counts = {};
          const edges = {};

          pages.forEach(p => {
            const tags = Array.from(new Set((p.tags || []).map(t => (t || '').toString().toLowerCase())));
            if (tags.length < 1) return;
            tags.forEach(t => {
              if (!t) return;
              counts[t] = (counts[t] || 0) + 1;
            });
            for (let i = 0; i < tags.length; i++) {
              for (let j = i + 1; j < tags.length; j++) {
                const a = tags[i];
                const b = tags[j];
                if (!a || !b) continue;
                const key = a < b ? a + '|' + b : b + '|' + a;
                edges[key] = (edges[key] || 0) + 1;
              }
            }
          });

          const nodes = Object.keys(counts).map(name => ({
            id: name,
            count: counts[name]
          }));
          if (!nodes.length) return;
          nodes.sort((a, b) => b.count - a.count);
          const maxNodes = 14;
          const topNodes = nodes.slice(0, maxNodes);
          const nodeIndex = new Map(topNodes.map((n, i) => [n.id, i]));

          const graphEdges = [];
          Object.keys(edges).forEach(key => {
            const [a, b] = key.split('|');
            if (!nodeIndex.has(a) || !nodeIndex.has(b)) return;
            graphEdges.push({ source: a, target: b, weight: edges[key] });
          });

          const width = 420;
          const height = 360;
          const svgNS = 'http://www.w3.org/2000/svg';
          const svg = document.createElementNS(svgNS, 'svg');
          svg.setAttribute('viewBox', `0 0 ${width} ${height}`);
          svg.setAttribute('class', 'tag-graph-svg');

          const centerX = width / 2;
          const centerY = height / 2;

          // Initialize nodes with random positions around center
          const simNodes = topNodes.map((n, i) => ({
            id: n.id,
            count: n.count,
            x: centerX + (Math.random() - 0.5) * 120,
            y: centerY + (Math.random() - 0.5) * 120,
            vx: 0,
            vy: 0
          }));
          const idToNode = new Map(simNodes.map(n => [n.id, n]));

          const simEdges = graphEdges.map(e => ({
            source: idToNode.get(e.source),
            target: idToNode.get(e.target),
            weight: e.weight
          })).filter(e => e.source && e.target);

          const maxW = simEdges.reduce((m, e) => Math.max(m, e.weight), 1);

          // Create SVG elements
          const edgeEls = simEdges.map(edge => {
            const line = document.createElementNS(svgNS, 'line');
            line.setAttribute('class', 'tag-graph-edge');
            const w = 0.6 + (edge.weight / maxW) * 1.4;
            line.setAttribute('stroke-width', w.toFixed(2));
            svg.appendChild(line);
            return line;
          });

          const nodeEls = simNodes.map(node => {
            const g = document.createElementNS(svgNS, 'g');
            g.setAttribute('class', 'tag-graph-node');

            const circle = document.createElementNS(svgNS, 'circle');
            circle.setAttribute('class', 'tag-graph-circle');
            circle.setAttribute('r', 10 + Math.min(node.count, 8));
            g.appendChild(circle);

            const label = document.createElementNS(svgNS, 'text');
            label.setAttribute('class', 'tag-graph-label');
            label.setAttribute('text-anchor', 'middle');
            label.textContent = node.id;
            g.appendChild(label);

            svg.appendChild(g);
            return { g, circle, label };
          });

          container.appendChild(svg);

          // Simple force-directed layout
          const chargeStrength = -340;
          const linkDistance = 150;
          const linkStrength = 0.07;
          const centerStrength = 0.015;
          const damping = 0.9;

          let dragging = null;

          function tick() {
            // Apply repulsion
            for (let i = 0; i < simNodes.length; i++) {
              for (let j = i + 1; j < simNodes.length; j++) {
                const a = simNodes[i];
                const b = simNodes[j];
                let dx = b.x - a.x;
                let dy = b.y - a.y;
                let distSq = dx * dx + dy * dy || 0.01;
                let force = chargeStrength / distSq;
                const dist = Math.sqrt(distSq);
                dx /= dist;
                dy /= dist;
                a.vx += force * dx;
                a.vy += force * dy;
                b.vx -= force * dx;
                b.vy -= force * dy;
              }
            }

            // Apply spring forces
            simEdges.forEach(edge => {
              const a = edge.source;
              const b = edge.target;
              let dx = b.x - a.x;
              let dy = b.y - a.y;
              let dist = Math.sqrt(dx * dx + dy * dy) || 0.01;
              const diff = dist - linkDistance;
              const force = linkStrength * diff;
              dx /= dist;
              dy /= dist;
              const fx = force * dx;
              const fy = force * dy;
              a.vx += fx;
              a.vy += fy;
              b.vx -= fx;
              b.vy -= fy;
            });

            // Apply centering force and integrate
            simNodes.forEach(node => {
              if (dragging === node) return;
              node.vx += (centerX - node.x) * centerStrength;
              node.vy += (centerY - node.y) * centerStrength;
              node.vx *= damping;
              node.vy *= damping;
              node.x += node.vx;
              node.y += node.vy;
            });

            // Update SVG positions
            simEdges.forEach((edge, i) => {
              const line = edgeEls[i];
              const a = edge.source;
              const b = edge.target;
              line.setAttribute('x1', a.x);
              line.setAttribute('y1', a.y);
              line.setAttribute('x2', b.x);
              line.setAttribute('y2', b.y);
            });

            simNodes.forEach((node, i) => {
              const { circle, label } = nodeEls[i];
              circle.setAttribute('cx', node.x);
              circle.setAttribute('cy', node.y);
              label.setAttribute('x', node.x);
              label.setAttribute('y', node.y + 4);
            });

            requestAnimationFrame(tick);
          }

          function findHitNode(x, y) {
            let hit = null;
            simNodes.forEach((node) => {
              const r = 10 + Math.min(node.count, 8);
              const dx = node.x - x;
              const dy = node.y - y;
              if (!hit && dx * dx + dy * dy <= r * r + 6) {
                hit = node;
              }
            });
            return hit;
          }

          function toLocal(svg, clientX, clientY) {
            const pt = svg.createSVGPoint();
            pt.x = clientX;
            pt.y = clientY;
            const local = pt.matrixTransform(svg.getScreenCTM().inverse());
            return { x: local.x, y: local.y };
          }

          // Drag interaction (mouse + touch)
          svg.addEventListener('mousedown', (e) => {
            const local = toLocal(svg, e.clientX, e.clientY);
            const hit = findHitNode(local.x, local.y);
            if (hit) {
              dragging = hit;
              dragging.vx = 0;
              dragging.vy = 0;
            }
          });

          svg.addEventListener('mousemove', (e) => {
            if (!dragging) return;
            const local = toLocal(svg, e.clientX, e.clientY);
            dragging.x = local.x;
            dragging.y = local.y;
            dragging.vx = 0;
            dragging.vy = 0;
          });

          svg.addEventListener('mouseup', () => {
            dragging = null;
          });

          svg.addEventListener('mouseleave', () => {
            dragging = null;
          });

          svg.addEventListener('touchstart', (e) => {
            if (!e.touches || e.touches.length === 0) return;
            const t = e.touches[0];
            const local = toLocal(svg, t.clientX, t.clientY);
            const hit = findHitNode(local.x, local.y);
            if (hit) {
              dragging = hit;
              dragging.vx = 0;
              dragging.vy = 0;
              e.preventDefault();
            }
          }, { passive: false });

          svg.addEventListener('touchmove', (e) => {
            if (!dragging || !e.touches || e.touches.length === 0) return;
            const t = e.touches[0];
            const local = toLocal(svg, t.clientX, t.clientY);
            dragging.x = local.x;
            dragging.y = local.y;
            dragging.vx = 0;
            dragging.vy = 0;
            e.preventDefault();
          }, { passive: false });

          svg.addEventListener('touchend', () => {
            dragging = null;
          });

          svg.addEventListener('touchcancel', () => {
            dragging = null;
          });

          tick();
        })();
      </script>
    </section>
  {{ end }}
{{ end }}
